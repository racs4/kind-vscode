// where the mouse is at the document
Lsp.Hover.Orig: Type
  Maybe<Pair<Nat,Nat>>

// A hover reference
// orig: where the mouse is at the document
// term: the term hovered
// type: type of the term hovered
type Lsp.Hover.Ref {
  new(
    orig: Lsp.Hover.Orig,
    term: Kind.Term,
    type: Maybe<Kind.Term>,
  )
}

Lsp.Hover.Result: Type
  Pair<Kind.Term, List<Lsp.Hover.Ref>>

// on_hover looks up what appears in the source file `uri` at the given
// `offset` and returns information about the term.
Lsp.on_hover(
  uri: String
  offset: Nat
  name: Kind.Name
  lsp_defs: Lsp.Check.Defs
): Maybe<String>
  let lsp_defs = Map.values!(lsp_defs)
  // All definitions contained in hovered file
  let file_defs = List.filter!((d) String.ends_with(uri, d@file), lsp_defs)

  // The definition that contains the hovered term
  let lsp_def = List.find!(Lsp.on_hover.find.offset_in_def(offset), file_defs)
  
  Maybe {
    get lsp_def = lsp_def
    // log(List.show!((x) open x; Lsp.on_hover.show.ref(x.fst@fst, x.snd) | "\n", Lsp.Defs.Map.to_list(lsp_def@refs)))
    get type    = Lsp.on_hover.find_ref(offset, name, lsp_def@refs)
    return Lsp.on_hover.show.ref(name, type)
  }

// FINDS
// ================================

// find which definition contains offset
Lsp.on_hover.find.offset_in_def(offset: Nat, lsp_def: Lsp.Check.Def): Bool
  open lsp_def
  Nat.between(lsp_def.orig@fst, offset, lsp_def.orig@snd)

// find which term (ref) of definition contains offset
Lsp.on_hover.find_ref(
  offset: Nat
  name: Kind.Name
  refs: Lsp.Defs.Map
): Maybe<Kind.Term>
 Lsp.on_hover.find_ref.go(offset, name, refs, none) 

Lsp.on_hover.find_ref.go(
  offset: Nat
  name: Kind.Name
  refs: Lsp.Defs.Map
  result: Maybe<Kind.Term>
): Maybe<Kind.Term>
  case refs {
    tip: result
    bin: 
      let node_name   = refs.key@fst
      let node_offset = refs.key@snd
      let node_type   = refs.val
      let cmp = String.cmp(name, node_name)
      case cmp {
        eql:
          if Nat.gte(offset, node_offset) then
            Lsp.on_hover.find_ref.go(offset, name, refs.right, some(node_type))
          else
            Lsp.on_hover.find_ref.go(offset, name, refs.left, result)
        ltn: Lsp.on_hover.find_ref.go(offset, name, refs.left, result)
        gtn: Lsp.on_hover.find_ref.go(offset, name, refs.right, result)
      }
  }

// Lsp.on_hover.find_ref(
//   offset: Nat
//   refs:   List<Lsp.Hover.Ref>
// ): Maybe<Lsp.Hover.Ref>
//   Lsp.on_hover.find_ref.go(offset, refs, none)

// Lsp.on_hover.find_ref.go(
//   offset: Nat
//   refs:   List<Lsp.Hover.Ref>
//   result: Maybe<Lsp.Hover.Ref>
// ): Maybe<Lsp.Hover.Ref>
//   case refs {
//     nil: result
//     cons: 
//       let ref = refs.head
//       let ref_orig = ref@orig

//       if Maybe.if!((x) Nat.between(x@fst, offset, x@snd), ref_orig)then
//         case result {
//           none: Lsp.on_hover.find_ref.go(offset, refs.tail, some(ref))
//           some:
//             let res_orig = result.value@orig
//             case ref_orig res_orig {
//               none none: Lsp.on_hover.find_ref.go(offset, refs.tail, result)
//               none some: Lsp.on_hover.find_ref.go(offset, refs.tail, result)
//               some none: Lsp.on_hover.find_ref.go(offset, refs.tail, some(ref))
//               some some: 
//                 let res_orig = res_orig.value
//                 let ref_orig = ref_orig.value

//                 if ref_orig@fst >? res_orig@fst then
//                   Lsp.on_hover.find_ref.go(offset, refs.tail, some(ref))
//                 else if ref_orig@snd <? res_orig@snd then
//                   Lsp.on_hover.find_ref.go(offset, refs.tail, some(ref))
//                 else if (ref_orig@fst =? res_orig@fst) && (ref_orig@snd =? res_orig@snd) then
//                   Lsp.on_hover.find_ref.go(offset, refs.tail, some(ref))
//                 else 
//                   Lsp.on_hover.find_ref.go(offset, refs.tail, result)
//             }
//         }
//       else
//         Lsp.on_hover.find_ref.go(offset, refs.tail, result)
//   }

// SHOW
// ============================

// show a reference orig
Lsp.on_hover.show.orig(orig: Lsp.Hover.Orig): String
  case orig {
    none: "",
    some: open orig.value Nat.show(orig.value.fst) | "-" | Nat.show(orig.value.snd)
  }

// show a term name
Lsp.on_hover.show.term_name(term: Kind.Term): String
  let res = case term {
    ref: term.name
    var: term.name
    all: term.name
    lam: term.name
    let: term.name
    def: term.name
    gol: term.name
    cse: term.name
    app: Kind.Term.show(term.func)
  } default ""
  
  // add ': ' if got some name
  case res {
    nil: ""
    cons: res | ": "
  }

Lsp.on_hover.show.type(type: Maybe<Kind.Term>): String
  Maybe.map!!((t) Kind.Term.show(t), type) <> ""

// show one reference
Lsp.on_hover.show.ref(name: Kind.Name, type: Kind.Term): String
  name | ": " |
  Lsp.on_hover.show.type(some(type))

// Lsp.on_hover.show.ref(ref: Lsp.Hover.Ref): String
//   open ref
  
//   Kind.Term.show(ref.term) | " // " |
//   Lsp.on_hover.show.term_name(ref.term) | 
//   Lsp.on_hover.show.type(ref.type) | " " |
//   Lsp.on_hover.show.orig(ref.orig)
